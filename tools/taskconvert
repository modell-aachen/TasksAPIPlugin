#!/usr/bin/perl

use strict;
use warnings;

use Cwd;
use Getopt::Long;

do '../bin/setlib.cfg';
require Foswiki;
require Foswiki::Func;
require Foswiki::Time;
require Foswiki::Plugins::ActionTrackerPlugin;
require Foswiki::Plugins::ActionTrackerPlugin::Action;
require Foswiki::Plugins::ActionTrackerPlugin::ActionSet;
require Foswiki::Plugins::ActionTrackerPlugin::Format;
require Foswiki::Plugins::TasksAPIPlugin;

# Configuration default values
my %cfg = (
  context    => '',
  defaults   => {},
  dateformat => {},
  force      => 0,
  form       => '',
  help       => 0,
  host       => '',
  list       => 0,
  map        => {},
  nodry      => 0,
  reindex    => 0,
  source     => [],
  verbose    => 0,
);

# Parse command line parameters
Getopt::Long::GetOptions(
  'context|c=s'      => \$cfg{context},
  'defaults=s%'      => \$cfg{defaults},
  'dateformats|d=s%' => \$cfg{dateformat},
  'force'            => \$cfg{force},
  'form|f=s'         => \$cfg{form},
  'help|h'           => \$cfg{help},
  'host=s'           => \$cfg{host},
  'list-fields|l'    => \$cfg{list},
  'map|m=s%'         => \$cfg{map},
  'nodry'            => \$cfg{nodry},
  'reindex'          => \$cfg{reindex},
  'source|s=s@'      => \$cfg{source},
  'verbose|v'        => \$cfg{verbose},
) or quit(1,1);

# Check whether to print the help page
quit(0, 1) if $cfg{help};

# collect possible source topics
$cfg{source} = [split(/,/, join(',', @{$cfg{source}}))];

# collect form and date field mappings
collectHashValues('dateformats', 'defaults', 'map');

quit(1,1) unless scalar @{$cfg{source}};
unless ($cfg{list}) {
  quit(1,1) unless $cfg{context};
  quit(1,1) unless $cfg{form};
}

if ($cfg{host}) {
  require Foswiki::Contrib::VirtualHostingContrib::VirtualHost;
  print "Processing host '$cfg{host}'...\n";
  Foswiki::Contrib::VirtualHostingContrib::VirtualHost->run_on($cfg{host}, \&process);
} else {
  process();
}

sub printHelp {
  my $help = <<HELP;

  -c    --context                     Defines the context to use for converted tasks.
                                      One of 'Web.Topic', '\$source' or 'regexp:PATTERN/REPLACEMENT'
                                      Usage:
                                        --context '\$source'
                                        --context 'MyWeb.MyTaskTopic'
                                        --context 'regexp:Tasks/' --source 'MyWeb.ActionTrackerTasks0001'
                                        --context 'regexp:Actions/' --source 'MyWeb.MyTopic00*Actions'

        --defaults                    List of key/value pairs holding default values for empty/missing form field values.
                                      Usage:
                                        --defaults 'AssignedTo=Team,Type=Information'
                                        --defaults 'AssignedTo=Team' --defaults 'Type=Information'

  -d    --dateformats                 List of key/value pairs defining a parsable date format to use for converting old
                                      date strings to new epoch strings.
                                      Usage:
                                        --dateformats 'created=\$epoch,due=\$epoch'
                                        --dateformats 'created=\$epoch' --dateformats 'due=\$epoch'

        --force                       Forces 'taskconvert' to create a TasksAPIPlugin task even if the according action
                                      is missing a mapped form field value. See also parameter '--defaults'.

  -f    --form                        The form to use for converted TasksAPI tasks.
                                      Usage:
                                        --form 'MyWeb.MyTaskForm'

  -h    --help                        Shows this help.

        --host                        Runs this script for the given virtual host. [requires VirtualHostingContrib]
                                      Usage:
                                        --host 'virtual.domain.tld'

  -l    --list-fields                 Reads source topics given by '--source' and prints all used field names of found actions.

  -m    --map                         List of key/value pairs to map old ActionTracker fields to new TasksAPI form fields.
                                      Usage:
                                        --map 'creator=Author,created=Created'
                                        --map 'creator=Author' --map 'created=Created'

        --nodry                       By default 'taskconvert' will not commit any changes to TasksAPIPlugin.
                                      Passing this flag will turn off that kind of a "dry run".
                                      Each found Action will be converted to a TasksAPIPlugin task.

        --reindex                     Forces TasksAPI to recreate its internal tasks index.

  -s    --source                      List of webtopics to read ActionTracker actions from.
                                      You may also use an asterisk as wildcard symbol.
                                      Usage:
                                        --source 'MyWeb.Topic1,MyWeb.Topic2'
                                        --source 'MyWeb.Topic1' --source 'MyWeb.Topic2'
                                        --source 'MyWeb.Topic00*'
                                        --source 'MyWeb.Topic00*Actions'

  -v    --verbose                     Enables verbose logging.

HELP
  print $help;
}

sub collectHashValues {
  foreach my $field (@_) {
    my @keys = keys %{$cfg{$field}};
    for my $k (@keys) {
      my $v = $cfg{$field}{$k};
      if ($v =~ /,/ && $v =~ /=/) {
        my @pairs = split(/,/, $v);
        $cfg{$field}{$k} = shift @pairs;
        foreach my $pair (@pairs) {
          my @map = split(/=/, $pair);
          $cfg{$field}{$map[0]} = $map[1];
        }
      }
    }
  }
}

sub process {
  new Foswiki('admin');

  Foswiki::Func::setPreferencesValue('tasksapi_suppress_logging', '1');
  foreach my $source (@{$cfg{source}}) {
    my ($web, $topic) = Foswiki::Func::normalizeWebTopicName(undef, $source);
    if ($topic =~ /\*/) {
      $topic =~ s/\*/\.\*/g;
      my @topics = Foswiki::Func::getTopicList($web);
      foreach my $t (@topics) {
        if ($t =~ /$topic/) {
          print "Processing source topic '$web.$t'...\n" if $cfg{verbose};
          processSource($web, $t) ;
        }
      }
    } else {
      print "Processing source topic '$web.$topic'...\n" if $cfg{verbose};
      processSource($web, $topic);
    }
  }
  Foswiki::Func::setPreferencesValue('tasksapi_suppress_logging', '0');
  Foswiki::Plugins::TasksAPIPlugin::_fullindex() if $cfg{reindex};
  exit 0;
}

sub processSource {
  my ($web, $topic) = @_;

  unless (Foswiki::Func::topicExists($web, $topic)) {
    print STDERR "Skipping given source '$web.$topic'. The specified webtopic doesn't exist!\n";
    return;
  }

  my ($fweb, $ftopic, $ctx);
  unless ($cfg{list}) {
    ($fweb, $ftopic) = Foswiki::Func::normalizeWebTopicName(undef, $cfg{form});
    unless ($cfg{form} && Foswiki::Func::topicExists($fweb, $ftopic)) {
      print STDERR "The given form '$cfg{form}' doesn't exist! Aborting!\n";
      exit 1;
    }

    $ctx = $cfg{context};
    $ctx = "$web.$topic" if $ctx =~ /^\$source$/;
    if (my ($pattern, $replace) = ($ctx =~ /^regexp:(.*?)\/(.*)$/)) {
      my $src = "$web.$topic";
      $src =~ s/$pattern/$replace/;
      $ctx = $src;
    }
  }

  my ($meta, $text) = Foswiki::Func::readTopic($web, $topic);
  my $set = Foswiki::Plugins::ActionTrackerPlugin::ActionSet::load($web, $topic, $text, 1);
  unless (scalar @{$set->{ACTIONS}}) {
    print "No actions found in source topic '$web.$topic'!\n" if $cfg{verbose};
    return;
  }

  foreach my $action (@{$set->{ACTIONS}}) {
    next unless $action && ref($action) && $action->isa('Foswiki::Plugins::ActionTrackerPlugin::Action');

    if ($cfg{list}) {
      while (my ($k, $v) = each %$action) {
        next if $k eq 'unloaded_fields';
        print "$k -> $v\n";
      }
      while (my ($k, $v) = each %{$action->{unloaded_fields}}) {
        print "$k -> $v\n";
      }
      print "\n\n";
      next;
    }

    my %task;
    my @missing;
    while (my ($k, $v) = each %{$cfg{map}}) {
      if ($action->{$k}) {
        $task{$v} = $action->{$k};
      } elsif ($action->{unloaded_fields}->{$k}) {
        $task{$v} = $action->{unloaded_fields}->{$k};
      } elsif ($cfg{defaults}{$v}) {
        print "Using default value for mapping of field '$k': $v -> $cfg{defaults}{$v}.\n" if $cfg{verbose};
        $task{$v} = $cfg{defaults}{$v};
      } else {
        push(@missing, $k);
        next;
      }

      if (defined $cfg{dateformat}{$k}) {
        $task{$v} = Foswiki::Time::formatTime($task{$v}, "$cfg{dateformat}{$k}");
      }
    }

    if (scalar @missing) {
      @missing = map {"$_ ($cfg{map}{$_})"} @missing;
      my $m = join(', ', @missing);
      print "Missing keys: $m for action $action->{uid}\n" if $cfg{verbose};
      next unless $cfg{force};
    }

    $task{Context} = $ctx;
    $task{form} = "$fweb.$ftopic";

    if ($cfg{nodry}) {
      my $t = Foswiki::Plugins::TasksAPIPlugin::Task::create(%task);
      print "Created task '$t->{id}'\n" if $cfg{verbose};
    } elsif ($cfg{verbose}) {
      print "---START NEW TASK---\n";
      while ( my ($k, $v) = each %task ) {
        print "$k -> $v\n";
      }
      print "---END NEW TASK---\n\n";
    }
  }
}

sub quit{
  my ($c, $h) = @_;
  printHelp() if $h;
  exit $c;
}

1;
